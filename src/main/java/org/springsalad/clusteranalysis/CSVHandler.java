package org.springsalad.clusteranalysis;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Stream;


//must be able to recognize ints and floats, other than the default String
public class CSVHandler {
    public static void main(String[] args) throws IOException{
    	/*
        Path outpath = Paths.get("C:\\Users\\imt_w\\Downloads\\test3.csv");

        DataFrame df = new DataFrame(new String[]{"Name","Age","Height (m)"});
        df.addRow(new Object[]{"Anna",15, 1.55});
        df.addRow(new Object[]{"Ben",16, 1.65});
        df.addRow(new Object[]{"Catherine",17, 1.75});
        df.addRow(new Object[]{"Deeee",18, 1.85});
        df.addRow(new Object[]{"Eeeeeeeeeeeee",19, 1.95});
        System.out.println(df);

        writeCSV(outpath,df.headers, df.frame);



        DataFrame df2 = readCSV(Paths.get("C:\\Users\\imt_w\\Downloads\\test2.csv"));
        System.out.println("Read back in, though the new headers were autogenerated");
        System.out.println(df2);

        DataFrame df3 = readCSV(Paths.get("C:\\Users\\imt_w\\Downloads\\test2.csv"),
                new String[]{"Name","Age","Height (m)"});
        System.out.println("Read back in, headers were manually given");
        System.out.println(df3);

        DataFrame df4 = readCSV(Paths.get("C:\\Users\\imt_w\\Downloads\\test1.csv"),0);
        System.out.println("Read back in, headers are from file");
        System.out.println(df4);
        */
    	Path path1 = Paths.get("C:\\Users\\imt_w\\Downloads\\MEAN_Run_0.0200_Size_Comp_Freq.csv");
    	System.out.println(readCSV(path1));
    	System.out.println(readCSV(path1, new String[] {"Size","Nck,NWASP,nephrin", "Frequency in clusters of the same size"}));
    	Path path2 = Paths.get("C:\\Users\\imt_w\\Documents\\SpringSalad\\Clustering_tutorial_01\\Clustering_tutorial_01_SIMULATIONS\\Simulation3_SIM_FOLDER\\data\\Cluster_stat\\Histograms\\Size_Comp_Freq\\MEAN_Run\\MEAN_Run_0.0200_Size_Comp_Freq.csv");
    	System.out.println(readCSV(path2,0));
    }

    //throws io exception if can't open or write
    public static void writeCSV(Path csvfilePath, String[] headers, List<?> ... columns)
            throws IOException{
        //check first
        for (List<?> column : columns) {
            if (column.size() != columns[0].size()) {
                throw new IllegalArgumentException("Cannot write to csv file " + csvfilePath.toString() +
                        ": columns not of the same length");
            }
        }

        //write file
        //each column element, call toString
        BufferedWriter bw = null;
        bw = new BufferedWriter(new FileWriter(new File(csvfilePath.toString())));

        for (int i = 0; i < headers.length; i++){
            String header = headers[i];
            bw.append(header);
            if (i<headers.length-1)
                bw.append(",");
        }
        bw.newLine();
        
        //FIXME use iterators instead. so that each column can be any collection
        for (int row = 0; row < columns[0].size(); row++) {
            for (int col = 0; col < columns.length; col++) {
                bw.append(columns[col].get(row).toString());
                if (col < columns.length - 1) bw.append(",");
            }
            bw.newLine();
        }

        try{
            bw.close();
        }
        catch (IOException ioe){
            ioe.printStackTrace();
        }
    }



    // reads first line to generate headers (0 1 2 etc) then calls read CSV with string headers
    public static DataFrame readCSV(Path csvfilePath) throws IOException{ // no headers to read
    	MyCSVReader myCSVReader= null;
        List<String> firstLine = null;
        List<Object> parsedLine;
        DataFrame df = null;

        myCSVReader = new MyCSVReader(new FileReader(csvfilePath.toString())); //possible IOE

        //boolean successful = true; //used when you don't want system exit when error occurs
        String[] generatedHeaders;
        firstLine = myCSVReader.readLine(); //possible IOE

        try {
        	myCSVReader.close();
        }
        catch (IOException w){
            w.printStackTrace();
        }
        //if (successful) {
            generatedHeaders = new String[firstLine.size()];
            for (int i = 0; i < generatedHeaders.length; i++) {
                generatedHeaders[i] = String.valueOf(i);
            }
            return readCSV(csvfilePath, generatedHeaders); //possible IOE
        //}
        //else return null;
    }

    // calls on complete the reading
    public static DataFrame readCSV(Path csvfilePath, String[] headers) throws IOException{
    	MyCSVReader myCSVReader = null;
        DataFrame df = new DataFrame(headers);

        myCSVReader = new MyCSVReader(new FileReader(csvfilePath.toString())); //possible IOE

        //boolean completeRead = true; //use this if you don't want system exit on exception
        try{
            completeTheReading(myCSVReader, df); //possible IOE
        }
        catch (IllegalArgumentException iae){
            throw new IllegalArgumentException(iae.getMessage() + "\nFile: " + csvfilePath.toString(), iae);
        }

        try {
        	myCSVReader.close();
        }
        catch (IOException w){
            w.printStackTrace();
        }
        //return (completeRead) ? df : null; //returns df only if whole file is read successfully
        return df;
    }

    // calls on complete the reading
    public static DataFrame readCSV(Path csvfilePath, int header) throws IOException{
        MyCSVReader myCSVReader = null;
        DataFrame df = null;

        if (header < 0){
            throw new IllegalArgumentException("Error in reading csvfile: header row cannot be negative");
        }
        myCSVReader = new MyCSVReader(new FileReader(csvfilePath.toString())); //possible IOE

        //boolean completeRead = true;
        List<String> headerLine = null;

        for (int i = 0; i <= header; i++) {
            headerLine = myCSVReader.readLine(); //possible IOE
            if (headerLine == null) {
                throw new IllegalArgumentException("Header row out of file row range");
            }
        }


        //if (completeRead) {
            String[] headerArray = headerLine.toArray(new String[0]);
            df = new DataFrame(headerArray);
            try {
                completeTheReading(myCSVReader, df); //possible IOE
            }
            catch (IllegalArgumentException iae){
                throw new IllegalArgumentException(iae.getMessage() + "\nFile: " + csvfilePath.toString(), iae);
            }
        //}
        try{
            myCSVReader.close();
        }
        catch (IOException ioe){
            ioe.printStackTrace();
        }
        //return (completeRead)? df: null;
        return df;
    }





    private static List<Object> parseCSVLineAsStrings(String csvLine){
        return parseCSVLine(csvLine, true);

    }

    private static List<Object> parseCSVLineAsObjects(String csvLine){
        return parseCSVLine(csvLine, false);

    }

    private static List<Object> parseCSVLine(String csvLine, boolean returnAsStrings){
        Scanner scan = new Scanner(csvLine).useDelimiter("\\s*,\\s*");
        List<Object> lineList = new ArrayList<>();
        String tmp;
        Object tmp2;
        while (scan.hasNext()){
            tmp = scan.next();
            try {
                tmp2 = Integer.valueOf(tmp);
            }
            catch (NumberFormatException nfe){
                try{
                    tmp2 = Double.valueOf(tmp);
                }
                catch (NumberFormatException nfe2){
                    tmp2 = tmp;
                }
            }
            lineList.add((returnAsStrings) ? tmp : tmp2);
        }
        return lineList;
    }
    
    // given the current state of the br and df
    // gives an exception when read line fails or when line is not the right length
    private static void completeTheReading_OLD(BufferedReader br, DataFrame df) throws IOException{
        String line;
        List<Object> parsedLine;
        while ((line = br.readLine()) != null){
            parsedLine = parseCSVLineAsObjects(line);
            df.addRow(parsedLine.toArray(new Object[0]));
        }
    }
    
    private static List<Object> parseCSVLine(List<String> line) {
    	List<Object> ret = new ArrayList<>();
    	for (String str: line) {
    		Object tmp;
    		try {
    			tmp = Integer.valueOf(str);
    		}
    		catch(NumberFormatException n) {
    			try {
    				tmp = Double.valueOf(str);
    			}
    			catch(NumberFormatException n2) {
    				tmp = str;
    			}
    		}
    		ret.add(tmp);
    	}
    	return ret;
    }
    
    private static void completeTheReading(MyCSVReader myCSVReader, DataFrame df) throws IOException {
    	List<String> line;
    	while ((line = myCSVReader.readLine()) != null) {
    		List<Object> parsedLine = parseCSVLine(line);
    		df.addRow(parsedLine.toArray());
    	}
    }
}


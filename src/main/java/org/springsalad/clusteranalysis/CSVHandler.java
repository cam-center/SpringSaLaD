package org.springsalad.clusteranalysis;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import static java.util.stream.Collectors.toList;


//must be able to recognize ints and floats, other than the default String
public class CSVHandler {
    public static void main(String[] args) throws IOException{
    	
        Path outpath = Paths.get("C:\\Users\\imt_w\\Downloads\\test4.csv");

        DataFrame df = new DataFrame(new String[]{"Name","Age","Height (m)"});
        df.addRow(new Object[]{"Anna",15, 1.55});
        df.addRow(new Object[]{"Ben",16, 1.65});
        df.addRow(new Object[]{"Catherine",17, 1.75});
        df.addRow(new Object[]{"Deeee",18, 1.85});
        df.addRow(new Object[]{"Eeeeeeeeeeeee",19, 1.95});
        System.out.println(df);

        writeCSV(outpath,df.headers, df.frame);


/*
        DataFrame df2 = readCSV(Paths.get("C:\\Users\\imt_w\\Downloads\\test2.csv"));
        System.out.println("Read back in, though the new headers were autogenerated");
        System.out.println(df2);

        DataFrame df3 = readCSV(Paths.get("C:\\Users\\imt_w\\Downloads\\test2.csv"),
                new String[]{"Name","Age","Height (m)"});
        System.out.println("Read back in, headers were manually given");
        System.out.println(df3);

        DataFrame df4 = readCSV(Paths.get("C:\\Users\\imt_w\\Downloads\\test1.csv"),0);
        System.out.println("Read back in, headers are from file");
        System.out.println(df4);
        
    	Path path1 = Paths.get("C:\\Users\\imt_w\\Downloads\\MEAN_Run_ACS_SD_ACO.csv");
    	System.out.println(readCSV(path1,0));
    	Path path2 = Paths.get("C:\\Users\\imt_w\\Documents\\SpringSalad\\Clustering_tutorial_01\\Clustering_tutorial_01_SIMULATIONS\\Simulation3_SIM_FOLDER\\data\\Cluster_stat\\Averages\\MEAN_Run_ACS_SD_ACO.csv");
    	System.out.println(readCSV(path2,0));
    	*/
    }

    //throws io exception if can't open or write
    public static void writeCSV(Path csvfilePath, String[] headers, Collection<?>... columns)
            throws IOException{
        //check first
        for (Collection<?> column : columns) {
            if (column.size() != columns[0].size()) {
                throw new IllegalArgumentException("Cannot write to csv file " + csvfilePath.toString() +
                        ": columns not of the same length");
            }
        }

        //write file
        //each column element, call toString
        BufferedWriter bw = null;
        bw = new BufferedWriter(new FileWriter(new File(csvfilePath.toString())));
        try {
	        for (int i = 0; i < headers.length; i++){
	            String header = headers[i];
	            bw.append(header);
	            if (i<headers.length-1)
	                bw.append(",");
	        }
	        
	        if (columns.length > 0) {
	        	bw.newLine();
		        List<Iterator<?>> columnIteratorList = Arrays.stream(columns).map(collection -> collection.iterator()).collect(toList());
		        for (int row = 0; row<columns[0].size(); row++) {
		        	int numberWritten = 0;
		        	int rowLength = columns.length;
		        	for (Iterator<?> columnIterator: columnIteratorList) {
		        		bw.append(columnIterator.next().toString());
		        		numberWritten++;
		        		if (numberWritten < rowLength) {
		        			bw.append(",");
		        		}
		        	}
		        	bw.newLine();
		        }
	        }
        }
        finally {
	        try{
	            bw.close();
	        }
	        catch (IOException ioe){}
        }
    }



    // reads first line to generate headers (0 1 2 etc) then calls read CSV with string headers
    public static DataFrame readCSV(Path csvfilePath) throws IOException{ // no headers to read
    	MyCSVReader myCSVReader= null;
        List<String> firstLine = null;
        List<Object> parsedLine;
        DataFrame df = null;

        myCSVReader = new MyCSVReader(new FileReader(csvfilePath.toString())); //possible IOE

        try {
	        String[] generatedHeaders;
	        firstLine = myCSVReader.readLine(); //possible IOE
	        if (firstLine == null) {
	        	throw new IOException("CSV file is empty; cannot infer headers: " + csvfilePath); //possible IOE
	        }
	        generatedHeaders = new String[firstLine.size()];
	        for (int i = 0; i < generatedHeaders.length; i++) {
	            generatedHeaders[i] = String.valueOf(i);
	        }
	        return readCSV(csvfilePath, generatedHeaders); //possible IOE
        }
        finally {
	        try {
	        	myCSVReader.close();
	        }
	        catch (IOException w){
	            w.printStackTrace();
	        }
        }
    }

    // calls on complete the reading
    public static DataFrame readCSV(Path csvfilePath, String[] headers) throws IOException{
    	MyCSVReader myCSVReader = null;
        DataFrame df = new DataFrame(headers);

        myCSVReader = new MyCSVReader(new FileReader(csvfilePath.toString())); //possible IOE

        try{
            completeTheReading(myCSVReader, df); //possible IOE
        }
        catch (DataFrame.IllegalShapeException ise){
            throw new UnexpectedFileContentException("CSV file contents do not form a proper table.\nFile: " + csvfilePath.toString(), ise);
        }
        finally {
	        try {
	        	myCSVReader.close();
	        }
	        catch (IOException w){
	            w.printStackTrace();
	        }
        }
        return df;
    }

    // calls on complete the reading
    public static DataFrame readCSV(Path csvfilePath, int header) throws IOException{
        MyCSVReader myCSVReader = null;
        DataFrame df = null;

        if (header < 0){
            throw new IllegalArgumentException("Error in reading csvfile: header row cannot be negative");
        }
        myCSVReader = new MyCSVReader(new FileReader(csvfilePath.toString())); //possible IOE

        List<String> headerLine = null;
        
        try {
	        for (int i = 0; i <= header; i++) {
	            headerLine = myCSVReader.readLine(); //possible IOE
	            if (headerLine == null) {
	                throw new IllegalArgumentException("Header row out of file row range");
	            }
	        }
	
	        String[] headerArray = headerLine.toArray(new String[0]);
	        df = new DataFrame(headerArray);
	        completeTheReading(myCSVReader, df); //possible IOE
        }
        catch (DataFrame.IllegalShapeException ise){
            throw new UnexpectedFileContentException("CSV file contents do not form a proper table.\nFile: " + csvfilePath.toString(), ise);
        }
        finally {
	        try{
	            myCSVReader.close();
	        }
	        catch (IOException ioe){
	            ioe.printStackTrace();
	        }
        }
        return df;
    }
   
    private static void completeTheReading(MyCSVReader myCSVReader, DataFrame df) throws IOException {
    	List<String> line;
    	while ((line = myCSVReader.readLine()) != null) {
    		//List<Object> parsedLine = parseCSVLine(line);
    		//df.addRow(parsedLine.toArray());
    		df.addRow(line.toArray());
    	}
    	numerifyDataFrame(df);
    }
    
    private static void numerifyDataFrame(DataFrame df) {
    	for (int col = 0; col<df.frame.length; col++) {
    		List<Object> stringSeries = df.getSeries(col);
    		List<Object> numericalSeries = new ArrayList<>();
    		boolean integerFailedTryingDouble = false;
    		boolean remainAsStrings = false;
    		int firstIndexWhereIntegerFailed = -1;
    		for (int row = 0; row<stringSeries.size(); row++) {
    			if (!integerFailedTryingDouble) {
    				try {
    					numericalSeries.add( Integer.valueOf( (String)stringSeries.get(row) ) );
    				}
    				catch (NumberFormatException nfe) {
    					integerFailedTryingDouble = true;
    					firstIndexWhereIntegerFailed = row;
    				}
    			}
    			if (integerFailedTryingDouble) {
    				try {
    					numericalSeries.add( Double.valueOf( (String)stringSeries.get(row) ) );
    				}
    				catch (NumberFormatException nfe) {
    					remainAsStrings = true;
    					break; // move on to next column
    				}
    			}
    		}
    		if (!remainAsStrings) {
	    		if (integerFailedTryingDouble) {
	    			for (int row = 0; row < firstIndexWhereIntegerFailed; row++) {
	    				numericalSeries.set(row, Double.valueOf((String)stringSeries.get(row)));
	    			}
	    		}
	    		df.frame[col] = numericalSeries;
    		}
    	}
    }
}

